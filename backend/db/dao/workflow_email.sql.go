// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: workflow_email.sql

package dao

import (
	"context"
)

const createWorkflowEmail = `-- name: CreateWorkflowEmail :one
INSERT INTO workflow_email (
    workflow_id,
    config,
    history_id,
    execution_state,
    last_synced_at,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, workflow_id, config, history_id, user_id, execution_state, last_synced_at, created_at, updated_at
`

type CreateWorkflowEmailParams struct {
	WorkflowID     int32  `json:"workflow_id"`
	Config         []byte `json:"config"`
	HistoryID      string `json:"history_id"`
	ExecutionState string `json:"execution_state"`
	LastSyncedAt   int64  `json:"last_synced_at"`
	CreatedAt      int64  `json:"created_at"`
	UpdatedAt      int64  `json:"updated_at"`
}

// CreateWorkflowEmail
//
//	INSERT INTO workflow_email (
//	    workflow_id,
//	    config,
//	    history_id,
//	    execution_state,
//	    last_synced_at,
//	    created_at,
//	    updated_at
//	)
//	VALUES ($1, $2, $3, $4, $5, $6, $7)
//	RETURNING id, workflow_id, config, history_id, user_id, execution_state, last_synced_at, created_at, updated_at
func (q *Queries) CreateWorkflowEmail(ctx context.Context, arg *CreateWorkflowEmailParams) (*WorkflowEmail, error) {
	row := q.db.QueryRow(ctx, createWorkflowEmail,
		arg.WorkflowID,
		arg.Config,
		arg.HistoryID,
		arg.ExecutionState,
		arg.LastSyncedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i WorkflowEmail
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Config,
		&i.HistoryID,
		&i.UserID,
		&i.ExecutionState,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getActiveWorkflowEmailsLocked = `-- name: GetActiveWorkflowEmailsLocked :many
WITH locked AS (
  SELECT
    we.id,
    w.user_id
  FROM workflow_email we
  INNER JOIN workflow w ON we.workflow_id = w.id
  WHERE we.execution_state = 'queued'
    AND we.last_synced_at IS NOT NULL
  FOR UPDATE OF we SKIP LOCKED
  LIMIT $1
)
UPDATE workflow_email
SET execution_state = 'running'
FROM locked
WHERE workflow_email.id = locked.id
RETURNING workflow_email.id, workflow_email.workflow_id, workflow_email.config, workflow_email.history_id, workflow_email.user_id, workflow_email.execution_state, workflow_email.last_synced_at, workflow_email.created_at, workflow_email.updated_at, locked.user_id
`

type GetActiveWorkflowEmailsLockedRow struct {
	ID             int32  `json:"id"`
	WorkflowID     int32  `json:"workflow_id"`
	Config         []byte `json:"config"`
	HistoryID      string `json:"history_id"`
	UserID         string `json:"user_id"`
	ExecutionState string `json:"execution_state"`
	LastSyncedAt   int64  `json:"last_synced_at"`
	CreatedAt      int64  `json:"created_at"`
	UpdatedAt      int64  `json:"updated_at"`
	UserID_2       string `json:"user_id_2"`
}

// GetActiveWorkflowEmailsLocked
//
//	WITH locked AS (
//	  SELECT
//	    we.id,
//	    w.user_id
//	  FROM workflow_email we
//	  INNER JOIN workflow w ON we.workflow_id = w.id
//	  WHERE we.execution_state = 'queued'
//	    AND we.last_synced_at IS NOT NULL
//	  FOR UPDATE OF we SKIP LOCKED
//	  LIMIT $1
//	)
//	UPDATE workflow_email
//	SET execution_state = 'running'
//	FROM locked
//	WHERE workflow_email.id = locked.id
//	RETURNING workflow_email.id, workflow_email.workflow_id, workflow_email.config, workflow_email.history_id, workflow_email.user_id, workflow_email.execution_state, workflow_email.last_synced_at, workflow_email.created_at, workflow_email.updated_at, locked.user_id
func (q *Queries) GetActiveWorkflowEmailsLocked(ctx context.Context, limit int32) ([]*GetActiveWorkflowEmailsLockedRow, error) {
	rows, err := q.db.Query(ctx, getActiveWorkflowEmailsLocked, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveWorkflowEmailsLockedRow
	for rows.Next() {
		var i GetActiveWorkflowEmailsLockedRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.Config,
			&i.HistoryID,
			&i.UserID,
			&i.ExecutionState,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkflowEmail = `-- name: UpdateWorkflowEmail :exec
UPDATE workflow_email
SET config = $2,
    history_id = $3,
    execution_state = $4,
    last_synced_at = $5,
    updated_at = $6
WHERE workflow_id = $1
`

type UpdateWorkflowEmailParams struct {
	WorkflowID     int32  `json:"workflow_id"`
	Config         []byte `json:"config"`
	HistoryID      string `json:"history_id"`
	ExecutionState string `json:"execution_state"`
	LastSyncedAt   int64  `json:"last_synced_at"`
	UpdatedAt      int64  `json:"updated_at"`
}

// UpdateWorkflowEmail
//
//	UPDATE workflow_email
//	SET config = $2,
//	    history_id = $3,
//	    execution_state = $4,
//	    last_synced_at = $5,
//	    updated_at = $6
//	WHERE workflow_id = $1
func (q *Queries) UpdateWorkflowEmail(ctx context.Context, arg *UpdateWorkflowEmailParams) error {
	_, err := q.db.Exec(ctx, updateWorkflowEmail,
		arg.WorkflowID,
		arg.Config,
		arg.HistoryID,
		arg.ExecutionState,
		arg.LastSyncedAt,
		arg.UpdatedAt,
	)
	return err
}
